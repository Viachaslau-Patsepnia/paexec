=head1 NAME

paexec - parallel executor

=head1 SYNOPSIS

B<paexec> I<[options]>

=head1 DESCRIPTION

Suppose you have a long list of AUTONOMOUS tasks that need to be
done, for example, you want to convert thousands of .wav audio files
to .ogg format.  Also suppose that multiple CPUs are
available, e.g. multi-CPU SMP system (or modern multikernel CPU) or a
cluster consisting of individual computers connected to the network or
internet. B<paexec> can efficiently do this work, that
is B<paexec> efficiently distributes different tasks to different
processors (or computers), receives the results of processing from them
and sends these results to stdout.

There are several notions that should be defined: I<task>, I<command>,
I<transport>, I<node>.

I<Tasks> are read by B<paexec> from stdin and are represented as one
line of text, i.e. one input line - one task.

I<node> identifier - remote computer or CPU identifier, for
example CPU ordinal number or computer's DNS name like
node12.cluster.company.com.

I<Command> - user's program that reads one-line task from stdin and sends
multiline result to stdout where an empty line means
JOB_IS_DONE__I_AM_READY_FOR_THE_NEXT_ONE. After sending the empty line
to stdout, stdout MUST BE FLUSHED. Remember that empty line
MUST NOT appears in general result lines. Otherwise B<paexec> may hang
because of deadlock.

I<Transport> - special program that helps to run I<command> on the
I<node>. It takes the I<node> identifier as its first
argument and I<command> with its arguments as the rest.  For example,
is '/usr/bin/ssh'. Both I<transport> and I<command> may 
be specified with their arguments, i.e. '/usr/bin/ssh -x' is allowed
as a I<transport> program.

Algorithm. I<Commands> are run on each I<node> with a help of
I<transport> program. Then, I<tasks> are read from stdin line-by-line
(one task per line)
and are sent to free I<node> (exactly one task per node at
a time). At the same time result lines are read from I<command's>
stdout and are output to B<paexec's> stdout. When an empty line is
obtained from the I<node> (this means that I<node> finished
its job) it is marked as free and becomes ready for the next
job. These steps repeat until the end of stdin is reached and all
I<nodes> finish their job.

More formally (to better understand how paexec works):

   run_command_on_each_node
   mark_all_nodes_as_free
   while not(end_of_stdin) or not(all_nodes_are_free)
      while there_is_free_node/i and not(end_of_stdin)
         task = read_task_from_stdin
         send_task_to_node(task, i)
         mark_node_as_busy(i)
      end
      while result_line_from_node_is_available/i
         result = read_result_line_from_node(i)
         send_line_to_stdout(result)
         if is_empty_line(result)
            # end of job
            mark_node_as_free(i)
         end
      end
   end
   close_command_on_each_node

Note that I<command> that does your actual task is run once (per node),
it is not restarted for every task.

Also note that output contains result lines (obtained from different
I<nodes>) in the mixed order. That is, the first line of the
output may contain a result line obtain from the first I<node>,
the second line of output - from the second I<node>, but the
third output line may contain result line from the first I<node>
again. It is also not guaranteed that the first line of output will be
from the first I<node> or from the first I<task>. All result
lines are output as soon as they are read by B<paexec>, i.e as soon as
they are ready to be output. B<paexec> works this way for the
efficiency reasons.  You can play with I<-l>, I<-r> and I<-p> options to see
what happens.

=head1 OPTIONS

=over 6

=item B<-h>|B<--help>

Display help information.

=item B<-V>|B<--version>

Display version information.

=item B<-c>|B<--cmd> I<command>

Command with its arguments

=item B<-t>|B<--transport> I<transport>

Transport command

=item B<-n>|B<--nodes> I<nodes>

=item B<-n>|B<--nodes> I<+number>

List of nodes (e.g. hostnames) separated by space character or (+
notation) a number of nodes.

Path to I<command>

=item B<-r>|B<--show-node>

Include node identifier or node number (0-based) to the
output, i.e. id/number of node that produces this particular
output line.  This identifier or number appears before line number if
I<-l> is also applied. Space character is used as a separator.

=item B<-l>|B<--show-line>

Include a 0-based task number (input line number) to the output,
i.e. line number from
which this particular output line was produced.  It appears before pid
if I<-p> is also applied. Space character is used as a separator.

=item B<-p>|B<--show-pid>

Include pid of paexec's subprocess that communicates with
I<node+command> to the output. Pid prepends the actual result
line. Space character is used as a separator.

=item B<-e>|B<--eot>

When end-of-task marker is obtained from node, an empty line is
printed to stdout. This option may be useful together with I<-l>
and/or I<-r>.

=item B<-E>|B<--eot-flush>

Imply B<-e> and flushes stdout.

=item B<-d>|B<--debug>

Turn on a debugging mode (for debugging purposes only)

=item B<-i>|B<--i2o>

Copy input lines (i.e. tasks) to stdout.

=item B<-I>|B<--i2o-flush>

Imply B<-i> and flushes stdout.

=item B<-s>|B<--pos>

Partially ordered set of tasks (orgraph) is read from stdin.

Instead of autonomous tasks, graph of the tasks is read from stdin.
In this mode every task can either FAIL or SUCCEED.
As always an empty line output by I<command> means I<end of task>.
The line before it shows an EXIT STATUS of the task.
The word "failure" means failure, "success" - success and
"fatal" means that the current task is reassigned to another node
(and restarted, of course) (see option -z).
See examples/1_div_x/1_div_X_cmd for the sample.
An input line (paexec's stdin) should contain
either single task without spaces inside
or two tasks separated by single space character,
e.g. task1<SPC>task2. task1<SPC>task2 line means that task1 must be done
before task2 and it is mandatory, that is if task1 I<fail> all dependent
tasks (including task2) are also failed recursively.
Tasks having dependencies are started only after all dependencies
are succeeded. When a task succeeds paexec outputs "success" word
just before end_of_task marker (see -e or -E), otherwise "failure"
word is output followed by a list of tasks failed because of it.

 Samples:

   tasks (examples/make_package/make_package_tasks file)

     textproc/dictem
     devel/autoconf wip/libmaa
     devel/gmake wip/libmaa
     wip/libmaa wip/dict-server
     wip/libmaa wip/dict-client
     devel/m4 wip/dict-server
     devel/byacc wip/dict-server
     devel/byacc wip/dict-client
     devel/flex wip/dict-server
     devel/flex wip/dict-client
     devel/glib2
     devel/libjudy

   command (examples/make_package/make_package_cmd__flex)

     #!/usr/bin/awk -f
     {
        print $0
        if ($0 == "devel/flex")
           print "failure"
        else
           print "success"

        print ""       # end of task marker
        fflush()
     }

   output of "paexec -s -l -c make_package_cmd__flex -n +10 \
              < make_package_tasks"

     3 devel/autoconf
     3 success
     4 devel/gmake
     4 success
     7 devel/m4
     7 success
     8 devel/byacc
     8 success
     9 devel/flex
     9 failure
     9 devel/flex wip/dict-server wip/dict-client 
     10 devel/glib2
     10 success
     11 devel/libjudy
     11 success
     1 textproc/dictem
     1 success
     2 wip/libmaa
     2 success

=item B<-z>|B<--resistant>

If applied, read/write(2) operations from/to nodes becomes not
critical. In case paexec has lost connection to the node, it will
reassign failed task to another node and, if -s applied, will output
"fatal" string to stdout ("success" + "failure" + "fatal").  This
makes paexec resistant to the I/O errors, as a result you can create
paexec clusters even over network consisting of unreliable hosts
(Internet?). Failed hosts are marked as such and will not be used
during the current run of paexec.

=item B<-Z> I<timeout>

When I<-z> applied, if a I<command> fails, appropriate node is marked
as broken and is excluded from the following task distribution. But if
B<-Z> applied, every I<timeout> seconds an attempt to rerun a comand
on a failed node is made. I<-Z> implies I<-z>. This option makes
possible to organize clusters over unreliable networks/hardware.

=back

=head1 EXAMPLES

=over 6

 paexec -t '/usr/bin/ssh -x' --nodes 'host1 host2 host3' \
        -l -c ~/bin/complex_task

 paexec -n +4 -c ~/bin/oggenc_wrapper

 paexec -EI -lr -n 'host1 host2 host3' \
                -c command -t /usr/bin/rsh |
 awk '
 ! ($2 in seen) {
     seen [$2] = 0

     node     = $1
     task_num = $2

     $1 = $2 = ""
     $0 = substr($0, 3)

     printf "task #%s (\"%s\") started on host \"%s\"\n", task_num, $0, node
     next
 }

 NF == 2 {
     printf "task #%s done\n", $2
     next
 }

 {
     task_num = $2
     $1 = $2 = ""
     print $0 > ("result." task_num ".txt")
 }'

 For other examples, see examples/ directory

=back

=head1 NOTES

On some systems long options may be not available.
Use short options to make programs more portable.

select(2) system call and non-blocking read(2) are used to read result
lines from I<nodes>.

At the moment blocking write(2) is used to send I<task> to the
I<node>. This may slow down an entire processing if I<tasks> are
too big. So, it is recommended to use shorter I<tasks>, for example,
filename or URI (several tens of bytes in size) instead of
multi-megabyte content. Though this may be fixed in the future.

=head1 ENVIRONMENT

=over 6

=item I<PAEXEC_BUFSIZE>

Overrides the compile time I<initial> size for internal buffers used
to store tasks and the result lines. Versions of B<paexec> prior to
0.9.0 used this value as a I<maximum> buffer size.
Now internal buffers are resized automatically.
If unsure, do not set PAEXEC_BUFSIZE variable.
See the default value in Makefile.

=back

=head1 AUTHOR/LICENSE

Copyright (c) 2007-2008 Aleksey Cheusov <vle@gmx.net>

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

=head1 BUGS/FEEDBACK

Please send any comments, questions, bug reports etc. to me by e-mail
or (even better) register them at sourceforge project home.  Feature
requests are also welcomed.

=head1 HOME

L<http://sourceforge.net/projects/paexec>

=head1 SEE ALSO
L<ssh(1)>
L<rsh(1)>
L<select(2)>
L<read(2)>
L<write(2)>
