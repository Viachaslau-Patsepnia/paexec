=head1 NAME

paexec - wrapper for AWK interpreter

=head1 SYNOPSIS

B<paexec> I<[options]>

=head1 DESCRIPTION

Suppose you have a long list of AUTONOMOUS tasks that need to be
done, for example, you want to convert thousands of .wav audio files
to .ogg format.  Also suppose that multiple CPUs (processors) are
available, e.g. multi-CPU SMP system (or modern multikernel CPU) or a
cluster consisting of individual computers connected with a network or
via internet. B<paexec> can efficiently do this work, that
is B<paexec> efficiently distributes different tasks to different
processors (or computers), receives the results of processing from them
(if any) and sends these results to stdout.

There are several notions that should be defined: I<task>, I<command>,
I<transport>, I<processor>.

I<Tasks> are read by B<paexec> from stdin and are represented as one
line of text, i.e. one input line - one task. There is no limit on the
size of task (a number of symbols in in) but it is recomended not to make
it too long (see DETAILS section below).

I<Processor> identifier - remote computer or CPU identifier, for
example CPU ordinal number or computer's DNS name like
node12.cluster.company.com.

I<Command> - user's program that reads one-line task from stdin and sends
multiline result to stdout where an empty line means
JOB_IS_DONE__I_AM_READY_FOR_THE_NEXT_ONE. After sending the empty line
to stdout, stdout MUST BE FLUSHED. Remember that empty line
MUST NOT appears in general result lines. Otherwise B<paexec> may hang
because of deadlock.

I<Transport> - special program that helps to run I<command> on the
I<processor>. It takes the I<processor> identifier as its first
argument and I<command> with its arguments as the rest.  For example,
is '/usr/bin/ssh'. Both I<transport> and I<command> may 
be specified with their arguments, i.e. '/usr/bin/ssh -x' is allowed
as a I<transport> program.

Algorithm. I<Commands> are run on each I<processor> with a help of
I<transport> program. Then, I<tasks> are read from stdin one-by-one
and are sent to free I<processors> (exactly one task per process at
the time). At the same time result lines are read from I<commands's>
stdout and are output to B<paexec's> stdout. When an empty line is
obtained from the I<processor> (this means that I<processor> finished
its job) it is marked as free and becomes ready for the next
job. These steps repeat until the end of stdin is reached and all
I<processors> finish their job.

More formally (to better understand how paexec works):

   run_command_on_each_processor
   mark_all_processors_free
   while not(end_of_stdin) or not(all_processors_are_free)
      while there_is_free_processor/i and not(end_of_stdin)
         task = read_task_from_stdin
         send_task_to_processor(task, i)
         mark_processor_as_busy(i)
      end
      while result_line_from_processor_is_available/i
         result = read_result_line_from_processor(i)
         send_line_to_stdout(result)
         if is_empty_line(result)
            # end of job
            mark_processor_as_free(i)
         end
      end
   end
   close_command_on_each_processor

Note that I<command> that do your actual job is run on the remote
processor once at startup, it is not restarted for every job.

Also note that output contains result lines (obtained from different
I<processors>) in the mixed order. That is, the first line of the
output may contain a result line obtain from the first I<processor>,
the second line of output - from the second I<processor>, but the
third output line may contain result line from the first I<processor>
again. It is also not garanteed that the first line of output will be
from the first I<processor> or from the first I<task>. All result
lines are output as soon as they are read by B<paexec>, i.e as soon as
they are ready to be output. B<paexec> works this way for the
efficiency reasons.  You can play with I<-l> and I<-k> options to see
what happens.

=head1 OPTIONS

=over 6

=item B<-h>|B<--help>

Display help information.

=item B<-V>|B<--version>

Display version information.

=item B<-c>|B<--cmd> I<command>

Command with its arguments

=item B<-n>|B<--procs> I<processors|+number>

List of processors (e.g. hostnames) separated by space character or (+
nonation) a number of processors.

Path to I<command>

=item B<-p>|B<--show-pid>

Include pid of paexec's subprocess that communicates with
I<processor+command> to the output. Pid prepands the actual result
line. Space character is used as a separator.

=item B<-l>|B<--show-line>

Include line number (0-based) to the output, i.e. from which task
(stdin line number) this particular output line is produced.
It appears before pid if I<-p> is also applied. Space
character is used as a separator.

=item B<-d>|B<--debug>

Turn on a debugging mode (for debugging purposes only)

=back

=head1 DETAILS/INTERNALS

accept(2) system call and non-blocking read(2) are used to read
I<tasks> from stdin and result lines from I<processors>.

At the moment blocking write(2) operation is used to send I<task> to
the I<processor>. This may slow down entire processing if I<tasks> are
too long. So, it is recommended to use shorter I<tasks>, for example,
filename or URI (several tens of bytes in size) instead of
multi-megabyte content. Though this may be fixed in the future.

=head1 AUTHOR/LICENSE

Copyright (c) 2007-2008, Aleksey Cheusov <vle@gmx.net>

Permission to use, copy, modify, distribute and sell this software
and its documentation for any purpose is hereby granted without
fee, provided that the above copyright notice appear in all copies
and that both that copyright notice and this permission notice
appear in supporting documentation.  I make no
representations about the suitability of this software for any
purpose.  It is provided "as is" without express or implied
warranty.

=head1 BUGS/FEEDBACK

Please send any comments, questions, bug reports etc. to me by e-mail
or (even better) register them at sourceforge project home.  Feature
requests are also welcomed.

=head1 HOME

L<http://sourceforge.net/projects/paexec>

=head1 SEE ALSO
L<accept(2)>
L<read(2)>
L<write(2)>
L<ssh(1)>
L<rsh(1)>
